\documentclass[a4paper, titlepage]{report}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}         % marges
\usepackage{graphicx}         % images
\usepackage{verbatim}         % texte préformaté
\usepackage{url}
\usepackage{listings}

\title{Rapport projet Cassiopée 93\\ \large Structural souce code properties}      % renseigne le titre
\author{Julien DENIZE \\ \and Cyprien LAMBERT \\ \and Tuteur: Jorge-Eleazar LOPEZ-CORONADO}           %   "   "   l'auteur
\date{25 mai 2019}           %   "   "   la future date de parution

\begin{document}

\maketitle
\tableofcontents

% --- inserer votre code LaTeX ici ---

\chapter{Introduction}
\section{Qu'est ce que l'optimisation}
\subsection{Définition}
Selon la définition donnée par Wikipédia:
\begin{quote}
    En programmation informatique, l'optimisation de code est la pratique consistant à améliorer l'efficacité du code informatique ou d'une librairie logicielle. \cite{wiki:Optimisation_de_code}
\end{quote}
Ainsi l'optimisation en informatique fait partie intégrante du développement. En effet, il est crucial pour différentes raisons détaillés à la section suivante que les développeurs optimisent leur code afin d'améliorer son rendement.

Des recherches ont donc été effectuées durant de nombreuses années au début de l'informatique afin d'optimiser le compilateur par exemple, pour avoir des compilations plus rapides ou/et plus efficaces. Aujourd'hui encore, la rercheche en optimisation est importante car mêmes si les machines sont de plus en plus puissantes, les algorithmes sont de plus en plus gourmands également.

Le Big Data illustre parfaitement ceci, les machines peuvent traiter des millions et des millions de données, mais si les algorithmes mettent des mois à s'exécuter, alors cela aurait eu peu de valeur.

\subsection{Problèmes à résoudre par optimisation}
Les optimisations permettent d'améliorer nombreuses choses: une exécutions plus rapide, une place en mémoire réduite, une limitation des ressources consommées comme les fichiers et enfin une diminution de la consommation électrique.

En effet, les optimisations permettent de supprimer des choses inutiles par exemple le code suivant
\begin{lstlisting}
int foo(const int d) {
    int a = d;
    int b = 1 + a;
    return b;
}
\end{lstlisting}
pourrait être optimisé de la façon suivante:
\begin{lstlisting}
int foo(const int d) {
    return 1 + d;
}
\end{lstlisting}
Cette "simple" optimisation permet de répondre aux différents critères d'amélioration. Le code est plus rapide, plus court donc il prend moins de place en mémoire, consomme moins d'énergie et enfin il utilise moins de ressources en RAM.

\subsection{Outils existants}
De très nombreux outils plus ou moins connus sont dédiés à l'optimisation de code, et ce dans tous les languages de programmation. La bibliothèque de compilation GCC\footnote{GCC (GNU Compiler Collection) est une suite de logiciels libres de compilation. On l'utilise dans le monde Linux dès que l'on veut transcrire du code source en langage machine, c'est le plus répandu des compilateurs. - \url{https://doc.ubuntu-fr.org/gcc}}, par exemple permet à l'utilisateur d'appliquer facilement nombre d'optimisations à son code. L'optimisation présentée à la section précédente est par exemple appliquée par GCC.

Les outils procèdent généralement à une analyse statique du code afin de l'optimiser ou de signaler des erreurs aux programmeurs. Cela signifie que le programme analysé n'est pas exécuté mais que les outils procèdent à une analyse syntaxique du programme afin d'étudier sa structure. L'analyse dynamique, avec exécution du programme, est d'avantage utilisée pour faire des tests afin de vérifier que le programme répond à des spécifications.  


\section{Notre approche}
\subsection{Les Control Flow Graphs (CFG)}
Nous nous sommes d'abord concentrés sur les Control Flow Graphs qui sont un outil essentiel en optimisation de compilation et permettent de visualiser le code en suivant son flux par la modélisation d'un graphe. Il permet donc d'observer tous les chemins possibles d'un programme en séparant l'arbre en plusieurs branches lorsqu'il y a notemment des conditions.
\subsection{Détection de code mort}
Après avoir obtenu quelques résultats sur les CFG, nous avons décidé de nous tourner vers le problème de la détection de code mort. En effet, une branche importante de l'optimisation est de détecter le code qui n'est jamais exécuté dans un programme afin de le supprimer, ou de détecter des erreurs.
\subsection{Notre projet}
Le but de notre projet était à l'origine d'étudier la structure des codes sources de différents programmes afin de détecter des similitudes entre ces structures et les CFG. Après avoir procédé au développement de deux outils, nous nous sommes finalement tourné vers le problème de détection de code mort sur lequel il y a encore beaucoup de recherches. 

\chapter{Control Flow Graphs}
\section{Introduction}
\section{Nos recherches}
\section{Implémentation}
\subsection{Notre script de modifications des CFG}
\subsection{Notre analyse des CFG}

\chapter{Dead Code Detection}
\section{Introduction}
\section{Nos recherches}
\section{Implémentation}

\bibliographystyle{plain}
\bibliography{rapport}

\end{document}